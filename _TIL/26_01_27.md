# I/O - Stream

데이터의 입출력을 처리하는 개념

노드(node): 입력과 출력의 끝단
- cosole 대표적인 입출력 노드

스트림(Stream):
- 데이터를 전송하는 **단방향** 통로
- 두 노드를 연결하고 데이터를 전송할 수 있는 개념
- 물의 흐름이나 전기의 흐름과 같은 개념
- 스트림은 단방향으로 흐르며 입력과 출력을 같이 처리할 수 없음

### 방향
입력 스트림 : input stream, reader
- 노드(외부)에서 자바로 데이터를 읽어들이는 통로

출력 스트림 : outpur stream, writer
- 자바에서 노드(외부)로 데이터를 내보내는 통로

### 데이터 타입
byte 단위로 데이터를 처리하는 스트림
- `XXX`InputeStream
- `XXX`OutputStream

char 단위로 데이터를 처리하는 스트림
- `XXX`Reader
- `XXX`Writer

## Node Stream

아래 조건에 따라 최종 노드 스트림이 결정됨
- 데이터 타입 : byte or char
- 방향 : input or output
- 노드 타입 : 키보드, 콘솔, file, array, pipe...

콘솔
- 입력
  - System.in
- 출력
  - System.out
  
파일
- 입력
  - 텍스트 파일
    - FileReader
  - 이미지, 동영상, 바이너리 파일
    - FileInputStream
- 출력
  - 텍스트 파일
    - FileWriter
  - 이미지, 동영상, 바이너리 파일
    - FileOutputStream

### Input Stream

`-1`을 읽으면 더이상 읽을게 없다

스트림을 사용하고 나면 `close()`를 사용해 종료해줘야한다. 안하면 리소스릭 발생 가능

- 바이트 한 개씩 읽기
- Buffer 만큼 씩 읽기

### Reader

### File

`.`의 위치는 자바 프로그램이 실행되는 위치

## 보조 스트림

filter stream, processing stream이라고 부름

다른 스트림에 부가적인 기능을 제공하는 스트림

스트림 체이닝 (Stream Chaining)
- 필요에 따라 여러 보조 스트림을 연결해서 사용 가능

이전 스트림을 생성자의 파라미터에 연결

```java
new BufferedInputStream(System.in);

new ObjectInputStream(new BufferInputStream(new FileInputStream()));
```

단독 사용 불가

반드시 노드 스트림과 함께 사용
- byte 단위 -> char 단위
  - InputSreamReader
    - new InputStreamReader(System.in)
      - byte 데이터 단위를 char 단위로 변경
- 입출력 속도 향상
  - Bufferd`XXX`
    - new BufferedReader(new InputStreamReader(System.in))
      - BufferedReader를 통해 콘솔 입력 속도 향상
- 객체 직렬화/역직렬화
  - `나중에 추가`

---

사용할 스트림 결정 과정
- 노드가 무엇인가
- 타입은 문자열인가? 바이트인가
- 방향이 무엇인가
- 추가 기능이 필요한가 - 보조 스트림 구성
  
키보드에서 유니코드 문자를 안전하고 빠르게 읽고 싶다면
1. 노드       : keyboard
2. 타입       : byte - 키보드에서 char를 읽을 수 없음
3. 방향       : 읽기
4. 노드 스트림 : InputStream - System.in
5. 보조 스트림 : InputStreamReducer
6. 보조 스트림 : BufferReader - 보조 스트림

메모리 객체를 파일로 저장하고 싶다면
1. 노드       : File
2. 타입       : Byte
3. 방향       : 쓰기 - 저장하기
4. 노드 스트림 : FileOutputStream
5. 보조 스트림 : ObjectOutputStream - 보조 스트림

## 보조 스트림 활용

데이터가 들어오면 일단 버퍼에 저장

BufferdReader를 사용하면 일단 빠름

### 객체 직렬화 serialization

객체를 파일등에 저장하거나 네트워크로 전송하기 위해 연속적인 데이터로 변환하는 것<br>
반대의 경우는 역 직렬화(deserialization)

직렬화된 데이터를 읽어와 역 직렬화 후 메모리에 적재

#### 직렬화 조건

- Serializable 인터페이스를 구현할 것
- 클래스의 모든 멤버가 Serializable 인터페이스를 구현해야 함
- 직렬화에서 제외하려는 멤버는 transient 선언
- static 변수도 직렬화에서 제외됨 - 객체 직렬화

```java
class Person implements Serializable {
    private String name; //  직렬화 필수 조건
    private int age; //  직렬화 필수 조건

    private transient String ssn; // 직렬화 제외
    private LoginInfo lInfo; // 직렬화 필요
}
```

#### serialVersionUID

클래스의 변경 여부를 파악하기 위한 유니크 키

직렬화 할 때의 UID와 역 직렬화 할 때의 UID가 다를 경우 예외 발생

직렬화되는 객체에 UID가 설정되지 않았을 경우 컴파일러가 자동 생성
- 멤버 변경으로 인한 컴파일 시마다 변경 -> InvalidClassException 초래

직렬화되는 객체에 대해서 serialVersionUID 설정 권장


지정
```java
private static final long serialVersionUID = 3906141983886065501L;
```

## Scanner와 BufferedReader

- char 형태의 데이터를 읽기 위한 클래스들
- Scanner - 자동 형변환을 지원하는 등 사용이 간편하지만 속도가 느림
- BufferedReader - 직접 스트림을 구성해야 하는 등 번거롭지만 속도가 빠름

# XML

Extensible Markup Language

HTML과 달리

- 필요에 따라서 태그를 확장해서 사용 가능
- 정확한 문법을 지켜야 동작 : Well formed

## 기본 문법
- 문서의 시작은
```xml
<?xml version="1.0" encoding="UTF-8"?>
```
- 반드시 root element가 존재해야 한다.
  - 나머지 태그들은 Tree 형태로 구성된다.
- 시작 태그와 종료 태그는 일치
- 시작 태그는 key-value 구조의 속성을 가질 수 있다.
  - 속성 값은 `" "` 또는 `' '`로 묶어서 표현한다.
- 태그는 대소문자를 구별한다.

# SAX

## 파싱

문서에서 필요한 정보를 얻기 위해 태그를 구별하고 내용을 추출하는 과정
- 전문적인 parser 활용

### SAX parser

Simple API XML parser

문서를 읽으면서 태그의 시작, 종료 등 이벤트 기반으로 처리하는 방식

### DOM parser

Document Object Model parser

문서를 다 읽고 난 후 문서 구조 전체를 자료구조에 저장하여 탐색하는 방식

문서를 완전히 메모리에 로딩 후 필요한 내용 찾기

DOM Tree
- 문서를 구성하는 모든 요소를 Node(태그, 속성, 값)루성
- 태그들은 root 노드(주소록)을 시작으로 부모, 자식 관계 구성


SAX는 빠르고 한번에 처리하기 때문에 다양한 탐색이 어렵다.

DOM은 다양한 탐색이 가능하지만 느리고 무거우며 큰 문서를 처리하기 어렵다.

## DTO

Data Transfer Object

계츨 간 데이터 교환을 위해 사용되는 객체

- Presentation layer
- business logic layer

필요한 데이터만 캡슐화

## record 클래스

데이터를 보관하는데 사용되는 불변 객체를 간단하고 명료하게 정의 가능

불변의 DTO를 구현할 때 유용

### 주요 특징

- 불변성
  - 객체의 상태는 객체 생성 시 정의되며 이후는 변경할 수 없음
  - 모든 field가 final