# 상속

상위 클래스의 자산(멤버)을 자신 (하위) 클래스에서 재사용하기 위한 것

생성자와 초기화 블록은 상속하지 않는다.

상위 클래스의 코드를 변경하면 모든 하위 클래스들에게도 적용 -> 유지 보수성 향상

```java
public class Person {
    String name;

    void eat(){}
    void jump(){}
}

public class SpiderMan extends Person {
    boolean isSpider;
    void fireWeb(){}
}
```

## 특징

### 중복 코드 제거

A, B 클래스의 공통 변수, 메서드를 부모 클래스로 작성하여 상속

### 확장 가능

기존 코드를 수정하지 않고, 새로운 클래스를 추가해서 기능 확장

### 다형성 지원

하나의 객체가 여러개의 타입을 가진다.

```java
// 다형성 지원 예시

class Animal {
    void sound() {}
}

class Dog extends Animal {
    void sound() {}
}

class Cat extends Animal {
    void sound() {}
}

public class Test {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();
    }
}
```

## 상속 관계

 상속 관계는 `is a` 혹은 `kind of`라고 표현함

 - Person is a Object
 - SpiderMan is a Person
  
자식 클래스
- 하위 클래스
- 서브 클래스

조상 클래스
- 상위 클래스
- 슈퍼 클래스

 ## 단일 상속

 다중 상속은 관계 복잡도가 생길 수 있음

 자바는 단일 상속만 지원

 대신 포함 관계를 지원함

 ## 포함 관계

 포함 관계는 `has a`라고 표현함

 2개 이상의 클래스에서 특성을 가져올 때 하나는 상속 나머지는 멤버 변수로 처리

 ```java
 public class SpiderMan extends Person {
	Spider spider; // has a
	boolean isSpider;
    ...
 }
```

## sealed class

특정 클래스에게만 상속 가능

의도치 않은 상속으로 인한 복잡성 감소

- sealed :  봉인된 클래스 추가적으로 `permits` 필요
- final : 더 이상 상속 불가 클래스
- non-sealed : 자유롭게 상속 가능한 클래스


### sealed class

```java
// Algo, CS, Java에만 상속 가능
sealed class SealedStudyGroup permits Algo, CS, Java {}

// 더 이상 상속 불가
final class Algo extends SealedStudyGroup {}

// Spring에만 상속 가능
sealed class Java extends SealedStudyGroup permits Spring {}

// 자유롭게 상속 가능
non-sealed class CS extends SealedStudyGroup {}

class Network extends CS {}
final class Spring extends Java {}
```

## 메서드 재정의

### 메서드 오버라이딩(overriding)

조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정(재정의)하는 것

```java
public class Person {
    void jump() {
        System.out.println("1m 점프");
    }
}

public class Spider {
   void jump() {
        System.out.println("100m 점프");
    } 
}

public class SpiderMan extends Person {
    Spider spider = new Spider();
    boolean isSpider;

    void fireWeb() {
        if(isSpider) {
            spider.fireWeb();
        } else {
            System.out.println("사람일땐 안 됨");
        }
    }

        void jump() {
        if(isSpider) {
            spider.jump();
        } else {
            System.out.println("1m 점프");
        }
    }
}
```

#### 오버라이딩 규칙

- 메서드 이름이 같아야 한다.
- 파라미터의 개수, 타입, 순서가 같아야 한다.
- 리턴 타입이 같아야 한다.
- 접근 제한자는 부모 보다 범위가 넓거나 같아야 한다.
- 조상보다 더 큰 예외를 더질 수 없다.

## super

`this`를 통해 멤버에 접근하듯, `super`를 통해 조상 클래스 멈버 접근

`super`를 이용해 조상 클래스 멤버의 변수와 메서드 재사용

```java
void jnmp() {
    if(isSpider) {
        spider.jump();
    } else {
        super.jump(); // 조상 메서드 재사용
    }
}
```

### 변수의 scope

사용된 위치에서 점점 확장해가며 처음 만난 선언부에 연결됨

method 내부 -> 해당 클래스 멤버 변수 -> 조상 클래스 멤버 변수

```java
class Parent {
	String x = "parent";
}

class Child extends Parent {
	String x = "child";

	void method() {
		String x = "method";
		System.out.println(x); // method
		System.out.println(this.x); // child
		System.out.println(super.x); // parent
	}
}
```

### 생성자

`this()`가 해당 클래스의 다른 생성자를 호출하듯 `super()`는 조상 클래스의 생성자 호출

- 조상 클래스에 선언된 멤버들은 조상 클래스 생성자에서 초기화됨.
- 자식 클래스에 선언된 멤버들만 자식 클래스 생성자에서 초기화됨.

`super()`는 자식 클래스 생성자의 맨 첫 줄에서만 호출 가능

- 즉 생성자의 첫 줄에만 `this()` 또는 `super()`가 올 수 있다.
  
명시적으로 this() 또는 `super()`를 호출하지 않는 경우 컴파일러가 `super()` 삽입
- 결론적으로 최상위 Object까지 객체가 생성 됨

```java
class Person {
	String name;
	
	Person(String name) {
		// super(); Object의 기본 생성자 호출
		this.name = name;
	}
}
```

#### 생성자 호출과 객체 생성

입력한 파라미터에 따라 알맞은 생성자가 호출됨

```java
class Person {
	String name;
	Person(String name) {
		this.name = name;
	}
}

class Spider {}

class SpiderMan extends Person{
	Spider spider;
	boolean isSpider;
	
	SpiderMan(String name, Spider spider, boolean isSpider){
		super(name);
		this.spider = spider;
		this.isSpider = isSpider;
	}
	
	SpiderMan(String name) {
		this(name, new Spider(), true);
	}
	
	SpiderMan() {
		this("김거미");
	}
}

public static void main(String[] args) {
    SpiderMan sp1 = new SpiderMan("피터 파커");
    SpiderMan sp2 = new SpiderMan();
}
```

## Annotation

사전적 의미 : 주석

#### Depercated

컴파일러에게 해당 메서드가 deprecated 되었다고 명시

#### Override

컴파일러에게 해당 메서드는  override한 메서드 임을 명시

`@Override`가 선언된 경우 반드시 super class에 선언된 메서드 여야 함

#### SuppressWarnings

컴파일러에게 사소한 warning의 경우 신경 쓰지 말라고 명시

# import

다른 패키지에 선언된 클래스를 사용하기 위한 키워드

패키지와 달리 여러번 선언 가능

```java
import java.io.InputStream;
import java.util.*;

public  class ImportTest {
    Date date;
    List listl;

    InputStream input;
    java.awt.List List2;
}
```

# 제한자

클래스, 변수, 메서드 선언부에 함께 사용해 부가적인 의미 부여

하나의 대상에 여러 제한자를 조합 가능하나, 접근 제한자는 하나만 사용 가능

## 종류

### 접근 제한자
- public
- protected
- default = package
- private

### 그 외
- static : 클래스 레벨의 요소 설정
- final : 요소를 더 이상 수정할 수 없게 함
- abstract : 추상 메서드 및 추상 클래스 작성
- syschronized : 멀티스레드에서 동기화 처리
...


## final

더 이상 바뀔 수 없음

### final class

더 이상 확장(상속) 할 수 없음.

상속을 금지하고 오버라이딩을 방지함

```java
final class Perfectclass {...}

//The type FinalClassTexst cannot subclass the final class PerfectClass
public class FinalClassTest extends PerfectClass 