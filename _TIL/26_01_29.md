# 스탯

## 특성

물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조

스택은 선형 자료 구조를 갖는다.

```
자료 구조는
- 선형 구조 : 자료간의 관계가 1대1의 관계를 갖는다.
- 비선형 구조 : 자료간의 관계가 1대N의 관계를 갖는다. (예 : 트리)
```

스택을 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음

후입 선출 구조 (LIFO, Last In First Out)
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
- in 1 2 3 -> out 3 2 1

## 주요 메서드
- push()
- pop()
- peek()
- isEmpty()
- size()

## 괄호의 종류

- 대괄호 `[]`
- 중괄호 `{}`
- 소괄호 `()`

### 조건
1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
3. 괄호 사이에는 포함 관계만 존재한다.

## Function call

싱글 스레딩 환경

프로그램에서의 함소 호출과 복귀에 따른 수행 선서를 관리
- 가장 마지막 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입 선출 구조의 스택을 이용하여 수행 순서 관리
- 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
- 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀 주소를 확인하고
- 함수 호출과 복귀에 따라 이과정을 반복하여 전체 프로그램이 수행이 종료되면 스택은 공백 스택이 된다.

## 계산기

문자열로 된 계산식이 주어질 때, 스택을 이 계산식의 값을 계산할 수 있다.

문자열 수식 계산의 일반적 방법
- 중위 표기법의 수식을 후위 표기법으로 변경한다.
- 후위 표기법의 수식을 스택을 이용하여 계산한다.

```
중위 표기법 - infix notation
- 연산자를 피연산자의 가운데 표기하는 방법
  - A+B
후위 표기법  - postfix notation
- 연산자를 피연산자 뒤에 표기하는 방법
  - AB+
```

# 반복과 재귀

반복과 재귀는 유사한 작업을 수행할 수 있음

반복은 수행하는 작업이 완료될 때 까지 계속 반복
  
재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용함
- 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
- 재귀 함수로 구현

재귀 -> 부분문제 -> 동일한 형태 구조(문제) -> 일반화
- 분할정복
- 백트래킹
- 하향식 재귀 DP

## 재귀함수 recursive function

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 재귀적 정의를 이용해서 재귀 함수를 구현
- 기본 부분(basis part)와 유도 부분(inductive part : 재귀 파생)로 구성
- 반복 구조에 비해 간결하고 이해하기 쉽다
- 메모리 구조에서 스택을 사용한다.
- 재귀 호출은 반복적인 스택의 사용을 의미
- 메모리 및 속ㅈ도에서 성능 저하가 발생

1. 함수 정의를 명확히
2. 기능 구현 설계시 자신의 작업과 나머지 작업으로 나누어 설계
  - 부분문제 식별
3. 함수의 수행을 결정짓는 결정적 요인이 되는 매개체가 되는 값 식별
4. 재귀의 기본부분 파악
  - 재귀의 탈출, 종료 조건

일반적으로 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.
입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.


# 큐 Queue

## 특성

스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조

선입건출구조 (FIFO: First In First Out)
- 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입 된 원소는 가장 먼저 삭제 된다.

큐는 머리(front)와 꼬리(rear)가 있음

데이터는 꼬리로 들어와 머리로 나감

데이터 삽입을 enQueue 삭제를 deQueue라고 함


## java.util.Queue

큐에 필요한 연산을 선언해 노ㅎ은 인터페이스

ArrayDeque 클래스를 Queue 인터페이스의 구현체로 많이 사용

LinkedList도 가능


스택, 큐는 동기화 처리가 필요 없음. 그래서 동기화 되는 LinkedList보다 ArrayDeque가 더 빠름

## 주요 메서드

- offer() : enQueue
- poll() : deQueue
- peek() : front
- isEmpty
- size()

# 조합

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Test {
	
	public static int combination(int n, int r) {
		if(n<r) throw new IllegalArgumentException();
		if(r==0 || n ==r) return 1;
		return combination(n-1, r-1)+combination(n-1, r);
	}
	
	public static void main(String[] args) throws Exception {
		System.out.println(combination(4, 1));
		System.out.println(combination(4, 2));
		System.out.println(combination(4, 3));
		System.out.println(combination(4, 4));
	}
}
```

# 변수의 일관성

변화량 : d - delta
다음 : n - next
방향 : dir - direction
행 : r(y) - row
열 : c(X) - column 