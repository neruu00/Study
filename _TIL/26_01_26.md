# 람다 Lambda

메서드 하나짜리 인터페이스를 짧게 쓴 문법

함수적 프로그래밍의 형태로 재사용 가능한 코드 블록

anonoymous inner class를 이용한 처리 방식을 간결하게 처리

```java
// Annonymous inner class
public void SortByAnonoymous() {
    Array.sort(langs, 
    new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
     })
}

// code block
public void SortByAnonoymous() {
    Array.sort(langs, 
        (o1, o2) -> o1.compareTo(o2);
    )
}
```

object 클래스에서 정의된 메서드는 lambda식을 사용하기 위한 abstract 메서드 수에 포함되지 않는다.

p != P 는 wrapper


# Stream

## fotEach

매개변수를 받아 리턴값이 없는 코드 작성

```java
.forEach(n -> System.out.println(n))
```

## filter

값 하나를 받아서 살릴지 말지 판단

매개 변수를 받아서 boolean을 리턴하는 코드 작성

```java
 
.filter(n -> n > 3)
```

## map

값을 받아서 다른 값으로 바꾸는 것이 목적

```java
.map(n -> n * 2)
```

## sorted

```java
.sorted((x, y)-> Integer.compare(y, x))
```

# 예외처리 exception handling

프로그램 실행 중 발생할 수 있는 예상 가능한 상황

| Error                           | Exception                                     |
| ------------------------------- | --------------------------------------------- |
| 애플리케이션을 잘못 작성한 경우 | 애플리케이션이 작성 의도와 달리 동작하는 경우 |
| 대응 불가                       | 대응 가능                                     |
| 메모리 부족, Stack Overflow     | null 객체 사용, 읽으려는 파일 없음            |

## 예외 클래스 계층

### checked exception

예외에 대한 대처 코드가 없으면 컴파일이 진행되지 않음

### unchecked exception

예외에 대한 대처 코드가 없더라도 컴파일은 진행됨

## try-catch

예외가 발생해도 프로그램이 죽지 않게 대응하기 위한 블록

```java
try {
    // 문제가 생길 수 잇는 코드
} catch (Exception e) {
    // 문제가 생겼을 때 실행
} finally {
    // 성공/실패 상관없이 항상 실행
}
```

- try
  - 예외가 발생할 수 있는 코드
- catch
  - 예외 발생 시 대처 코드
- finally
  - 정리 작업 (자원 반납)

## 다중 exception handling

```java
try {
    // exception 발생 가능한 코드
} catch (XXException) {
    // XXException 발생 시 처리 코드
} catch (YYException) {
    // XXException 발생 시 처리 코드
} catch (Exception) {
    // XXException 발생 시 처리 코드
}
```

## throw

의도적으로 예외를 발생시키는 문법

```java
throw new IllegalArgumentException("scat value");
```

### Throwable의 주요 메서드

| 메서드                        | 설명                                                                                                          |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------- |
| public String getMessage()    | 발생된 예이에 대한 구체적인 메시지를 반환한다.                                                                |
| public Throwable getCause()   | 예외의 원인이 되는Throwable 객체 또는 null 반환한다.                                                          |
| public void printStackTrace() | 예외가 발생된 메서드가 호출되기 전까지의 메서드의 호출 스택을 출력한다. <br> 디버깅의 수간으로 주호 사용된다. |

## throws

해당 메서드에서 예외를 처리하지 않고 호출한 쪽으로 예외를 떠넘기는 문법

API가 제공하는 메서드들은 사전에 예외가 발생할 수 잇음을 선언부에 명시하고 프로그래머가 그 예외에 대처하도록 강요

java API에서 예외처리를 해버릴 경우 개발자는 예외 상황을 인지할 수 없음

```java
class FileUtil {
	public static String readFile(String filename) throws IOException {
		return Files.readString(Path.of(filename));
	}
}

class FeatureA {
	public static String loadConfigForUI() {
		try {
			return FileUtil.readFile("src/day0126/config.txt");
		} catch (IOException e) {
			System.out.println("[경고] 설정 파일이 없어 기본 설정으로 실행합니다.");
			return "DEFAULT_CONFIG";
		}
	}
}

class FeatureB {
	public static void runCriticalJob() {
		try {
			String data = FileUtil.readFile("src/day0126/required.txt");
			System.out.println("필수 작업 시작: " + data);
		} catch (IOException e) {
			System.out.println("[치명] 필수 파일이 없습니다. 작업을 중단합니다.");
			return;
		}
	}
}
```
- featureA - 파일이 없으면 기본 값 사용
- featureB - 파일이 없으면 작업 중단
- readFile - 항상 고정적인 예외 처리

### 메서드 재정의

메서드 재정의 시 조상 클래스 메서드가 던지는 예외보다 상위 예외를 던질 수 없다.

`예시) 조상 메서드에서 IOException을 throws하는데 자식이 Exception을 throws 할 수 없음`

### 예외 변환 Exception Chaining

하위 계층에서 발생한 예외는 상위 계층에 맞는 예외로 바꿔서 던져야 한다.

## 사용자 정의 예외

---

파라미터도 없고 리턴도 없음 = runable

속도는 일반 코드가 stream 보다 빠름

set.parallel.Stream() -> 병렬처리 -> forkjoin -> 병렬이라고 항상 빠른것은 아님.

---

project -> 좌클 -> properties -> libraries -> library 선택 후 edit

-> 알고리즘은 se 1.8
-> 나머지는 se21