# Geniric

다양한 타입의 객체를 다루는 메서드.

컬렉션 클래스에서 컴파일 시에 타입 체크

```
**다형성의 장점**
1. 정보 저장 시 상위 타입으로 여러 하위 타입을 정보를 저장 가능
2. 메서드 작성 시, 매개변수를 타입별로 만들 필요없이 사위 타입의 메서드 하나만 작성하면 됨
```

제네릭은 다형성의 첫 번째 장점과 연관됨

클래스를 정의할 때 타입을 정하지 않고, 사용할 때 타입을 정할 수 있게 해주는 문법

### 사용하는 이유

1. 코드의 안정성
   - 값을 담을 때, 해당 타입에 맞는 값만 담을 수 있게 제한
2. 가독성
   - 값을 꺼내 쓸 때, 타입체크 및 형변환 코드 없이 바로 사용 가능

### Generic Type

클래스 또는 인페이스 선언시 `<>`에 타입 파라미터(형인자) 표시

```java
// T가 바로 타입 파라미터
public interface Interface_Name<T> {...}

// 무인자 자료형 (Raw Type)
public class Class_Name {...}

// 형인자 자료형 (Parameterized Type) 
public class Class_Name<T> {...}
```

### 형인자 Type Parameter

`임의의 참조형 타입`을 말함.

성격에 따라 선언
- T : reference `T`ype
- E : `E`lement
- K : `K`ey
- V : `V`alue


### 예시

#### 형인자

```java
public class ArrayList<E>

public class HashMap<K, V>
```

#### 제네릭 사용 X
```java
package day0123.generic;

class Box {
    private Object value;

    public void set(Object value) {
        this.value = value;
    }

    public Object get() {
        return value;
    }
}

public class NoGenericWithTypeCheck {
    public static void main(String[] args) {
        Box box = new Box();

        // 어떤 타입이든 들어갈 수 있음
        box.set("Hello");
        // box.set(123); // 실수로 다른 타입도 가능

        Object value = box.get();

        //타입 체크 및 형변환 코드 필요
        if (value instanceof String) {
            String text = (String) value;
            System.out.println(text.toUpperCase());
        }
    }
}

```

#### 제네릭 사용

```java
package day0123.generic;

class Box<T> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}

public class GenericExample {
    public static void main(String[] args) {
        Box<String> box = new Box<String>();

        // String만 담을 수 있음 (컴파일 타임 체크)
        box.set("Hello");
//         box.set(123); // 컴파일 에러

        // 타입 안정성
        // 형변환 없이 바로 사용
        String text = box.get();
        System.out.println(text.toUpperCase());
    }
}
```

#### 제한된 타입 파라미터

선택할 수 있는 타입 파라미터를 제한

```java
//T는 Number 또는 그 하위 타입만 가능
class Box<T extends Number> {
	private T value;

	public void set(T value) {
		this.value = value;
	}

	public T get() {
		return value;
	}

	public void test() {
		value.intValue();	//Number의 메서드 사용 가능!!
	}
}

public class BoundedTypeParameter {

	public static void main(String[] args) {

		// ⭕ 허용되는 타입들 (Number의 하위 타입)
		Box<Integer> intBox = new Box<>();
		intBox.set(10);

		Box<Double> doubleBox = new Box<>();
		doubleBox.set(3.14);

		System.out.println(intBox.get());
		System.out.println(doubleBox.get());

		// ❌ 컴파일 에러
		//		 Box<String> stringBox = new Box<>();
		//		 String은 Number의 하위 타입이 아님
	}
}
```


## 주의사항 3

Generic 타입의 배열 생성 불가

# wildcard

`추가 요망`

# enum

열거형 데이터 타입

 ```java
enum Grade {
    SALES,
    PART_TIME_JOB,
    NORMAL
}
 ```

enum 타입에 선언된 내용을 enum 상수로 불림

일반적인 상수 선언 룰을 따름


thread safe?

collection -> list 위치 기반 작업 가능

set에서 동일함의 조건은 equals만으로 부족할 경우 hashCode도 같아야 함

# 정렬

특정 기준에 따라 요소의 크기를 비교하여 내림차순 또는 오름차순으로 배치하는 것

정렬 가능한 Collection
- 배열, list 계열
- Set에서는 SortedSet 계열
- Map에서는  SortedMap 계열 (Key 기준)

```java
private List<String> names = Arrays.asList("Hi", "Java", "World", "Welcome");

public void basicSort() {
    Collection.sort(names);
    System.out.println(names); // [Hi, Java, Welcome, World]
}
```

## 정렬 방법

- 배열 정렬
  - Arrays.sort()
- Collections 정렬
  - Collections.sort()
- 요소들의 기본 정렬 기준을 가지고 정렬한다면?
  - 예) int, float, Integer, Double, String 등
- 새로운 기준으로 정렬할 때
  - Arrays.sort(배열, Comparator)
  - Collections.sort(컬렉션, Comparator)
- 우리가 알아야 하는 것?
  - Comparator 객체를 생성하는 방법